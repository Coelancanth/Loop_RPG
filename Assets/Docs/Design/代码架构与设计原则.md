## 1. 架构概览

### 1.1.1 分层与模块
整体采用分层与模块化架构，将游戏逻辑与表现层分离，并通过 Manager 类、Service 类和数据层进行管理。示意图如下：

```plaintext
+--------------------------------------------------------+
|                      Presentation                      |
|               (Unity Scenes, UI Prefabs)               |
+--------------------------+-----------------------------+
|         Managers         |           Systems           |
|  (GameManager, ... )     | (CombatSystem, PathSystem,  |
|                          |  ResourceSystem, ...)       |
+--------------------------------------------------------+
|        Data Access & Services (Data Models, Repos)     |
| (PlayerDataService, ResourceService, NetworkService)   |
+--------------------------------------------------------+
|                  Utility & Common Modules              |
|    (EventBus, Logging, Configuration, RandomGen)       |
+--------------------------------------------------------+

```

### 1.1.2 核心架构模式
- 采用 MVC + Service 分层架构
- 使用事件系统实现模块间解耦
- 采用单例模式管理全局服务
- 使用策略模式处理不同类型的游戏实体
- 采用观察者模式处理游戏事件


### 1.2 命名规范与约定
- 类名以大写开头，使用 PascalCase（如：`PathTile`、`ResourceManager`）。
- 接口名以 `I` 开头（如 `IResourceService`）。
- 脚本文件与类名一致，一个文件定义一个类。
- 测试类文件命名为 `{ClassName}Tests.cs`，存放于 `Tests` 目录内。
- 方法命名：

   - 使用 PascalCase。
   - 动词开头，表示具体的操作，例如：
        GetResourceCount、ValidatePath、StartBattle
   - 事件处理方法以 On 开头，例如：
        OnTilePlaced、OnResourceChanged

- 变量命名：

    - 局部变量和参数：camelCase。
        int resourceCount;
    - 类级字段：_camelCase（下划线开头），例如：
        _currentHealth、_tileList
    - 常量：全大写，单词之间用下划线分隔，例如：
        MAX_PLAYER_LEVEL、DEFAULT_TILE_COST

### 1.3 关键设计原则
- 依赖注入原则
- 单一职责原则
- 开闭原则
- 接口隔离原则
- 依赖倒置原则
- 组合优于继承原则
- 迪米特法则
- KISS原则
- 健壮性原则
- 数据驱动
- 拓展性设计
- 单一入口（Centralized Entry Point）
- 模块化开发

### 1.4 数据驱动的模块开发
引入更多 **数据驱动** 的设计思想，将游戏的核心逻辑通过配置文件或脚本定义：

-  **路径和 Tile 的属性**：通过 JSON 文件定义 Tile 类型及其效果（如资源消耗、增益）。
-  **敌人和 Boss 的行为**：将敌人 AI、攻击模式等从代码中剥离出来，使用数据配置增强灵活性。

### 1.5 模块间依赖优化

- 使用依赖注入
- 通过依赖注入，减少模块间的直接依赖，增强模块的可替代性

### 1.6 依赖倒置原则
核心思想：
- 高层模块（如系统逻辑）不应该直接依赖于低层模块（如具体实现），二者都应该依赖于抽象。
- 抽象（接口或基类）不应该依赖于具体实现，而具体实现应该依赖于抽象。

### 1.7 组合优于继承（Composition over Inheritance）
核心思想：
- 优先通过组合（将功能分解为独立组件并组合到对象中）实现功能，而不是通过继承（将所有功能集成到一个复杂的类层次中）。

### 1.8 迪米特法则（Law of Demeter, LoD）
核心思想：
- 一个模块或类不应该直接依赖过多的其他模块，只与其直接需要交互的模块通信。
- 简化模块间的依赖关系，降低耦合度。

### 1.9 测试驱动开发（Test-Driven Development, TDD）
核心思想：先写测试用例，再实现功能，确保代码符合预期。

- 核心模块（路径、战斗、资源管理）必须有覆盖率较高的单元测试。
- 例如，测试路径系统是否能够正确验证路径连续性。

### 1.10 日志与监控

- 统一日志系统：为调试提供标准化的日志输出。
- 错误监控：为关键模块（如资源系统、战斗系统）引入异常处理机制，避免运行时崩溃。

### 1.11 详细注释